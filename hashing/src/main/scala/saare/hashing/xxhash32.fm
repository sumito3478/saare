/*Copyright 2013 sumito3478 <sumito3478@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 */
package saare
package hashing

import saare._, Saare._
import unsafe._, Unsafe._
import Memory._
import java.lang.Integer.rotateLeft
import io.netty.buffer.ByteBuf

object XXHash32 {
  val prime1 = -1640531535
  val prime2 = -2048144777
  val prime3 = -1028477379
  val prime4 = 668265263
  val prime5 = 374761393
  <#assign bufTypes = ["Array[Byte]", "Array[Char]", "Array[Short]", "Array[Int]", "Array[Long]", "Array[Float]", "Array[Double]", "Long"]>
  <#list bufTypes as bufType>
  private[this] def hash_impl(buf: ${bufType}, off: Int, len: Int, seed: Int): Int = {
    checkAligned(buf, off, 4)
    <#if bufType?matches("Array\\[.*\\]")>
    val buf_base_offset = base_offset(buf)
    <#else>
    val buf_base_offset = 0
    </#if>
    var p = new Pointer(buf_base_offset + off)
    val end = p + len
    var h32 = if (len >= 16) {
      val limit = end - 16
      var v1 = seed + prime1 + prime2
      var v2 = seed + prime2
      var v3 = seed
      var v4 = seed - prime1
      do {
        v1 += p.intLE(buf) * prime2
        v1 = rotateLeft(v1, 13)
        v1 *= prime1
        p += 4
        v2 += p.intLE(buf) * prime2
        v2 = rotateLeft(v2, 13)
        v2 *= prime1
        p += 4
        v3 += p.intLE(buf) * prime2
        v3 = rotateLeft(v3, 13)
        v3 *= prime1
        p += 4
        v4 += p.intLE(buf) * prime2
        v4 = rotateLeft(v4, 13)
        v4 *= prime1
        p += 4
      } while (p <= limit)
      rotateLeft(v1, 1) + rotateLeft(v2, 7) + rotateLeft(v3, 12) + rotateLeft(v4, 18)
    } else {
      seed + prime5
    }
    h32 += len
    while (p <= end - 4) {
      h32 += p.intLE(buf) * prime3
      h32 = rotateLeft(h32, 17) * prime4
      p += 4
    }
    while (p < end) {
      h32 += (p.byte(buf) & 0xff) * prime5
      h32 = rotateLeft(h32, 11) * prime1
      p += 1
    }
    h32 ^= h32 >>> 15
    h32 *= prime2
    h32 ^= h32 >>> 13
    h32 *= prime3
    h32 ^= h32 >>> 16
    h32
  }
  </#list>
  def hash[A: MemoryViewable](buf: A, off: Int, len: Int, seed: Int): Int = {
    buf |> view |< off |< len match {
      case NativeMemory(p, _, _) => hash_impl(p, off, len, seed)
      <#assign valueTypes = ["Byte", "Char", "Short", "Int", "Long", "Float", "Double"]>
      <#list valueTypes as type>
      case ${type}HeapMemory(p, _, _) => hash_impl(p, off, len, seed)
      </#list>
    }
  }
}
